# 对数阶的时间复杂度

```
function foo(n) {
    let i = 1;
    while(i < n) {
        i *= 2
    }
}
```


```
function foo(n) {
    let i = 1;
    while(i < n) {
        i *= 3
    }
}
```

 * i的数值其实是等比数列 2 4 8 16 ... 2的x次方 = n
 * x=log2n
 * 不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。
 * 对数之间是可以互相转换的，log3n 就等于 log32 * log2n
 * 所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。
 * 基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。
 * 所以，O(log2n) 就等于 O(log3n)。
 * 因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。
 * 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。
 * O(nlogn) 也是一种非常常见的算法时间复杂度。
 * 比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。